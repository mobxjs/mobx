---
sidebar_label: Migrating from MobX 4/5 üöÄ
hide_title: true
---

<script async type="text/javascript" src="//cdn.carbonads.com/carbon.js?serve=CEBD4KQ7&placement=mobxjsorg" id="_carbonads_js"></script>

MobX 6 is quite different from MobX 5. This pages covers a migration guide from MobX 4 and 5 to 6, and an extensive list of all the changes.

# Migrating to MobX 6

(for the changelog, scroll down)

_‚ö†Ô∏è Disclaimer: Depending on factors like the size and complexity of your code base, your MobX usage patterns, and the quality of your automated tests, this migration guide might take you anywhere between an hour and a couple of days. Please refrain from upgrading if you don't trust your Continuous Integration or QA / test procedures enough to pick up any unexpected breakages. Unexpected behavioral changes might be caused by changes in MobX itself or the changes needed to your Babel / TypeScript build configuration. ‚ö†Ô∏è_

## Getting started

1. Update `mobx` to the latest version of MobX 4/5 and solve any deprecation messages.
2. Update `mobx` to version 6.
3. If you are upgrading from MobX 4, and you will need to support Internet Explorer / React Native without proxies, call `import { configure } from "mobx"; configure({ useProxies: "never" })` at the initialization of your application, to back-out of the Proxy implementation. See [Proxy Support](../refguide/configure.md#proxy-support) for more details.
4. For babel users:
    - If you are using Babel and have class-properties enabled, disable the legacy loose field support: `["@babel/plugin-proposal-class-properties", { "loose": false }]`
    - (Optional) In MobX 6 decorators have become opt-in. If you no longer wish to use decorators, remove `plugin-proposal-decorators` from your babel configuration and dependencies. See [decorators](../best/decorators.md) for more details.
5. For Typescript users
    - Add the flag `"useDefineForClassFields": true` to your compiler config.
    - (Optional) In MobX 6 decorators have become opt-in. If you no longer wish to use decorators, remove / disable the `experimentalDecorators` configuration from your TypeScript config. See [decorators](../best/decorators.md) for more details.
6. The MobX default configuration has become more strict. We recommend to adopt the new defaults after completing the upgrade (see [Configuring MobX](../refguide/configure.md)). During migration, we recommend to configure MobX in the same way as it would be in v4/v5 out of the box: `import {configure} from "mobx"; configure({ enforceActions: "never" });`. After finishing the entire migration process and validating that your project works as expected, consider enabling the flags `computedRequiresReaction`, `reactionRequiresObservable` and `observableRequiresReaction` and `enforceActions: "observed"` to write more idiomatic MobX code.

## Upgrading classes to use `makeObservable`

Due to standardized JavaScript limitations in how class fields are constructed, it is no longer possible for MobX to alter the behavior of class fields by means of decorators or the `decorate` utility. Instead, fields have to be made observable by the `constructor`. This can be done in three different ways:

1. Remove all decorators and call `makeObservable` in the `constructor` and explicitly define which field should be made observable using which decorator. For example: `makeObservable(this, { count: observable, tick: action, elapsedTime: computed })` (note that the second argument corresponds to what would be passed to `decorate`). This is the recommended approach if you want to drop decorators in your code base, and the project isn't yet too big.
2. Leave all the decorators and call `makeObservable(this)` in the `constructor`. This will pick up the metadata generated by the decorators. This is the recommended way if you want to limit the impact of a MobX 6 migration.
3. Remove decorators and use `makeAutoObservable(this)` in the class `constructor`'s.

See [makeObservable / makeAutoObservable](../refguide/observable.md) for more details.

Some specifics to note:

1. Using `makeObservable` / `makeAutoObservable` needs to be done in every class definition that declares MobX based members. So if a sub-class and super-class both introduce observable members, they will both have to call `makeObservable`.
2. `makeAutoObservable` will mark methods using a new decorator `autoAction`, that will apply `action` only if it is not in a derivation context. This makes it safe to call automatically decorated methods also from computed properties.

Migrating a large code base with lots of classes might be daunting. But no worries, there is a code-mod available that will automate the above process!!

## Upgrading your code with the `mobx-undecorate` codemod

If you are an existing MobX user you have code that uses a lot of decorators, or the equivalent calls to `decorate`.

The [`mobx-undecorate`](https://www.npmjs.com/package/mobx-undecorate) package provides a codemod that can automatically update your code to be conformant to MobX 6. There is no need to install it; instead you download and execute it using the [`npx`](https://www.npmjs.com/package/npx) tool which you do need to install if you haven't already.

To get rid of all uses of MobX decorators and replace them with the equivalent `makeObservable` calls, go to the directory that contains your source code and run:

```shell
npx mobx-undecorate
```

MobX will continue to support decorators -- so if you want to retain them
and only introduce `makeObservable(this)` where required, you can use the `--keepDecorators` option:

```shell
npx mobx-undecorate --keepDecorators
```

See [documentation](https://www.npmjs.com/package/mobx-undecorate) for more options.

### Limitations of `mobx-undecorate`

The `mobx-undecorate` command has to introduce a constructor in classes that do not yet have one. If base class of the constructor expects arguments, the codemod cannot introduce these arguments for the subclass being upgraded, and the `super` call won't pass them either. You have to fix these manually.
The tool will generate a `// TODO: [mobx-undecorate]` comment in these cases.

We do have a special case for React class components to do the right thing and
pass along `props` to the superclass.

# Changelog

## New features

-   [`makeObservable(target, annotations)`](../refguide/observable.md#makeobservable) is now the recommended way to make objects with a fixed shape observable, such as classes.
-   [`makeAutoObservable(target)`](../refguide/observable.md#makeautoobservable) is will automatically determine the annotations used by `makeObservable`. Methods will be marked as 'autoAction', so that they can be used both from a computed value or as stand alone method.
-   MobX 6 can be used in both modern environments, and environments that don't support Proxy. So both MobX 4 and 5 users can upgrade to 6. See [proxy support](../refguide/configure.md#proxy-support) for more details.
-   `observable.array` now supports `{ proxy: false }` as option.
-   `reaction`'s effect function now receives the previous value seen by the reaction as second argument.
-   `flow` can now be used as annotation as well. You might need `flowResult` in case you use TypeScript to extract the correct result type. [details](../refguide/action.md#-using-flow-instead-of-asyncawait).

## Breaking changes

### Changes that might affect you

-   The `decorate` API has been removed, and needs to be replaced by `makeObservable` in the constructor of the targeted class. It accepts the same arguments. The `mobx-undecorate` can transform this automatically.
-   When using `extendObservable` / `observable`, fields that contained functions used to be turned into observables. This is no longer the case, they will be converted into `autoActions`.
-   [Strict mode](../refguide/configure.md#enforceActions) for actions is now enabled by default in `observed` mode.
-   `toJS` no longer takes any options. It no longer converts Maps and Sets to plain data structures. Generic, flexible serialization of data structures is out of scope for the MobX project, and writing custom serialization methods is a much more scalable approach to serialization (tip: leverage `computed`s to define how class instances should be serialized).
-   The methods `intercept` and `observe` are no longer exposed on observable arrays, maps and boxed observables. Import them as utility from mobx instead: `import { observe, intercept } from "mobx"`, and pass the collection as first argument: `observer(collection, callback)`. Note that we still recommend to avoid these API's.
-   `observableMap.toPOJO()`, `observableMap.toJS()` have been dropped. use `new Map(observableMap)` instead if you want to convert an observable map to a plain Map shallowly.
-   `observableMap.toJSON()` now returns an entries array rather than a new Map, to better support serialization.
-   `observableSet.toJS()` has been dropped. Use `new Set(observableSet)` instead if you want to convert an observable Set to a plain Set shallowly.
-   `observableMap.toJSON()` now returns an array rather than a new Set, to better support serialization.
-   Sorting or reversing an observableArray in a derivation (without slicing first) will now throw rather than warn. In contrast, it is now allowed to sort or reverse observable arrays in-place, as long as it happens in an action.
-   `isArrayLike` is no longer exposed as utility. Use `Array.isArray(x) || isObservableArray(x)` instead.

### Obscure things that don't work anymore, but that probably won't affect you

-   It is no longer possible to re-decorate a field (through either `@observable` or `makeObservable`) that is already declared in a super class.
-   `runInAction` no longer supports passing a name as first argument. Name the original function or use `action(name, fn)()` if you cared about the debug name.
-   `computed(getterFn, setterFn)` no longer accepts a setter function as a second argument. Use the `set` option instead: `computed(getterFn, { set: setterFn })`.
-   In observable arrays, for `findIndex` / `find` method, the `offset` argument (the third one) is no longer supported, to be consistent with ES arrays.
-   The option `computedConfigurable` of `configure` is no longer supported as it is now the default.
-   `observableArray.toJS()` has been removed, use `observableArray.slice()` instead, which does the same.
-   Killed support for the `IGNORE_MOBX_MINIFY_WARNING` environment flag.
-   `_allowStateChangesInComputation(fn)` is no longer needed, use `runInAction(fn)` instead.
-   In `computed`, the when `predicate` (first arg), and `reaction` predicate (first arg) it is now forbidden to directly change state. State changes should be done in their effect functions, or otherwise at least wrapped in `runInAction` (only the state change, not the observables you want to track!). Note that this is still an anti pattern.
-   The `observableArray.get()` and `observableArray.set()` methods are no longer supported.
-   The `IObservableObject` interface is no longer exported from MobX.
-   The second argument to the `reaction` effect function, the disposer object, is now passed in as third argument. The second argument is now the previous value seen by the reaction.
-   `onBecomeObserved` / `onBecomeUnobserved` will now only trigger for observables that are actually used by a reaction (see [#2309](https://github.com/mobxjs/mobx/issues/2309) for background).

## Fixes

-   [#2326](https://github.com/mobxjs/mobx/issues/2326): Incorrect `this` for array callbacks such as in `array.forEach`
-   [#2379](https://github.com/mobxjs/mobx/issues/2379): Fixed issue with `array.concat`
-   [#2309](https://github.com/mobxjs/mobx/issues/2309): Fixed several inconsistencies between keepAlive'd computed values and `on(un)BecomeObserved`
-   Fixed several inconsistencies when `on(un)BecomeObserved` was triggered for observables changed in actions without having an observer
