<!DOCTYPE html><html lang="en"><head><meta charSet="utf-8"/><meta http-equiv="X-UA-Compatible" content="IE=edge"/><title>What does MobX react to? · MobX</title><meta name="viewport" content="width=device-width"/><meta name="generator" content="Docusaurus"/><meta name="description" content="# What does MobX react to?"/><meta name="docsearch:language" content="en"/><meta property="og:title" content="What does MobX react to? · MobX"/><meta property="og:type" content="website"/><meta property="og:url" content="https://mobx.js.org/index.html"/><meta property="og:description" content="# What does MobX react to?"/><meta property="og:image" content="https://mobx.js.org/img/undraw_online.svg"/><meta name="twitter:card" content="summary"/><meta name="twitter:image" content="https://mobx.js.org/img/undraw_tweetstorm.svg"/><link rel="shortcut icon" href="img/favicon.png"/><link rel="stylesheet" href="//cdnjs.cloudflare.com/ajax/libs/highlight.js/9.12.0/styles/default.min.css"/><script>
              (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
              (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
              m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
              })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

              ga('create', 'UA-65632006-1', 'auto');
              ga('send', 'pageview');
            </script><script type="text/javascript" src="https://buttons.github.io/buttons.js"></script><script type="text/javascript" src="https://codefund.app/properties/259/funder.js" async=""></script><script src="js/scrollSpy.js"></script><link rel="stylesheet" href="css/main.css"/><script src="js/codetabs.js"></script></head><body class="sideNavVisible separateOnPageNav"><div class="fixedHeaderContainer"><div class="headerWrapper wrapper"><header><a href=""><img class="logo" src="img/mobx.png" alt="MobX"/><h2 class="headerTitleWithLogo">MobX</h2></a><div class="navigationWrapper navigationSlider"><nav class="slidingNav"><ul class="nav-site nav-site-internal"><li class="siteNavGroupActive"><a href="intro/concepts.html" target="_self">Documentation</a></li><li class=""><a href="https://github.com/mobxjs/mobx" target="_self">Github</a></li></ul></nav></div></header></div></div><div class="navPusher"><div class="docMainWrapper wrapper"><div class="docsNavContainer" id="docsNav"><nav class="toc"><div class="toggleNav"><section class="navWrapper wrapper"><div class="navBreadcrumb wrapper"><div class="navToggle" id="navToggler"><div class="hamburger-menu"><div class="line1"></div><div class="line2"></div><div class="line3"></div></div></div><h2><i>›</i><span>Reacting to observables</span></h2><div class="tocToggler" id="tocToggler"><i class="icon-toc"></i></div></div><div class="navGroups"><div class="navGroup"><h3 class="navGroupCategoryTitle">Introduction</h3><ul class=""><li class="navListItem"><a class="navItem" href="README.html">Introduction</a></li><li class="navListItem"><a class="navItem" href="intro/concepts.html">Concepts &amp; Principles</a></li><li class="navListItem"><a class="navItem" href="intro/overview.html">The gist of MobX</a></li><li class="navListItem"><a class="navItem" href="refguide/api.html">API overview</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Making things observable</h3><ul class=""><li class="navListItem"><a class="navItem" href="refguide/observable.html">observable</a></li><li class="navListItem"><a class="navItem" href="refguide/observable-decorator.html">@observable</a></li><li class="navListItem"><a class="navItem" href="refguide/object.html">objects</a></li><li class="navListItem"><a class="navItem" href="refguide/array.html">arrays</a></li><li class="navListItem"><a class="navItem" href="refguide/map.html">maps</a></li><li class="navListItem"><a class="navItem" href="refguide/boxed.html">boxed values</a></li><li class="navListItem"><a class="navItem" href="refguide/modifiers.html">decorators</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Reacting to observables</h3><ul class=""><li class="navListItem"><a class="navItem" href="refguide/computed-decorator.html">(@)computed</a></li><li class="navListItem"><a class="navItem" href="refguide/autorun.html">autorun</a></li><li class="navListItem"><a class="navItem" href="refguide/when.html">when</a></li><li class="navListItem"><a class="navItem" href="refguide/reaction.html">reaction</a></li><li class="navListItem"><a class="navItem" href="refguide/observer-component.html">(@)observer</a></li><li class="navListItem navListItemActive"><a class="navItem" href="best/react.html">Understanding what MobX reacts to</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Changing observables</h3><ul class=""><li class="navListItem"><a class="navItem" href="refguide/action.html">action</a></li><li class="navListItem"><a class="navItem" href="best/actions.html">async actions &amp; flows</a></li><li class="navListItem"><a class="navItem" href="refguide/object-api.html">Object api</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Utility functions</h3><ul class=""><li class="navListItem"><a class="navItem" href="refguide/tojson.html">toJS</a></li><li class="navListItem"><a class="navItem" href="refguide/extend-observable.html">extendObservable</a></li><li class="navListItem"><a class="navItem" href="refguide/extending.html">createAtom</a></li><li class="navListItem"><a class="navItem" href="refguide/observe.html">intercept &amp; observe</a></li><li class="navListItem"><a class="navItem" href="refguide/create-transformer.html">mobxUtils.createTransformer</a></li><li class="navListItem"><a class="navItem" href="refguide/expr.html">mobxUtils.expr</a></li><li class="navListItem"><a class="navItem" href="refguide/mobx-utils.html">MobX-utils</a></li></ul></div><div class="navGroup"><h3 class="navGroupCategoryTitle">Tips &amp; Tricks</h3><ul class=""><li class="navListItem"><a class="navItem" href="faq/faq.html">Frequently Asked Questions</a></li><li class="navListItem"><a class="navItem" href="best/pitfalls.html">Common Pitfalls &amp; Best Practices</a></li><li class="navListItem"><a class="navItem" href="best/decorators.html">How to (not) use decorator syntax</a></li><li class="navListItem"><a class="navItem" href="best/trace.html">Using trace for debugging</a></li><li class="navListItem"><a class="navItem" href="best/store.html">Defining data stores</a></li><li class="navListItem"><a class="navItem" href="best/react-performance.html">Optimizing React components</a></li><li class="navListItem"><a class="navItem" href="refguide/spy.html">spy</a></li></ul></div></div></section></div><script>
            var coll = document.getElementsByClassName('collapsible');
            var checkActiveCategory = true;
            for (var i = 0; i < coll.length; i++) {
              var links = coll[i].nextElementSibling.getElementsByTagName('*');
              if (checkActiveCategory){
                for (var j = 0; j < links.length; j++) {
                  if (links[j].classList.contains('navListItemActive')){
                    coll[i].nextElementSibling.classList.toggle('hide');
                    coll[i].childNodes[1].classList.toggle('rotate');
                    checkActiveCategory = false;
                    break;
                  }
                }
              }

              coll[i].addEventListener('click', function() {
                var arrow = this.childNodes[1];
                arrow.classList.toggle('rotate');
                var content = this.nextElementSibling;
                content.classList.toggle('hide');
              });
            }

            document.addEventListener('DOMContentLoaded', function() {
              createToggler('#navToggler', '#docsNav', 'docsSliderActive');
              createToggler('#tocToggler', 'body', 'tocActive');

              var headings = document.querySelector('.toc-headings');
              headings && headings.addEventListener('click', function(event) {
                var el = event.target;
                while(el !== headings){
                  if (el.tagName === 'A') {
                    document.body.classList.remove('tocActive');
                    break;
                  } else{
                    el = el.parentNode;
                  }
                }
              }, false);

              function createToggler(togglerSelector, targetSelector, className) {
                var toggler = document.querySelector(togglerSelector);
                var target = document.querySelector(targetSelector);

                if (!toggler) {
                  return;
                }

                toggler.onclick = function(event) {
                  event.preventDefault();

                  target.classList.toggle(className);
                };
              }
            });
        </script></nav></div><div class="container mainContainer"><div class="wrapper"><div class="post"><header class="postHeader"><a class="edit-page-link button" href="https://github.com/mobxjs/mobx/edit/master/docs/best/react.md" target="_blank" rel="noreferrer noopener">Edit</a></header><article><div><span><h1><a class="anchor" aria-hidden="true" id="what-does-mobx-react-to"></a><a href="#what-does-mobx-react-to" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>What does MobX react to?</h1>
<div id='codefund' ></div>
<p>MobX usually reacts to exactly the things you expect it to.
Which means that in 90% of your use cases mobx &quot;just works&quot;.
However, at some point you will encounter a case where it might not do what you expected.
At that point it is invaluable to understand how MobX determines what to react to.</p>
<blockquote>
<p>MobX reacts to any <em>existing</em> <strong>observable</strong> <em>property</em> that is read during the execution of a tracked function.</p>
</blockquote>
<ul>
<li><em>&quot;reading&quot;</em> is dereferencing an object's property, which can be done through &quot;dotting into&quot; it (eg. <code>user.name</code>) or using the bracket notation (eg. <code>user['name']</code>).</li>
<li><em>&quot;trackable functions&quot;</em> are the expression of <code>computed</code>, the <code>render()</code> method of an observer component, and the functions that are passed as the first param to <code>when</code>, <code>reaction</code> and <code>autorun</code>.</li>
<li><em>&quot;during&quot;</em> means that only those observables that are being read while the function is executing are tracked. It doesn't matter whether these values are used directly or indirectly by the tracked function.</li>
</ul>
<p>In other words, MobX will not react to:</p>
<ul>
<li>Values that are obtained from observables, but outside a tracked function</li>
<li>Observables that are read in an asynchronously invoked code block</li>
</ul>
<h2><a class="anchor" aria-hidden="true" id="mobx-tracks-property-access-not-values"></a><a href="#mobx-tracks-property-access-not-values" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MobX tracks property access, not values</h2>
<p>To elaborate on the above rules with an example, suppose that you have the following observable data structure (<code>observable</code> applies itself recursively by default, so all fields in this example are observable):</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">let</span> message = observable({
    <span class="hljs-attr">title</span>: <span class="hljs-string">"Foo"</span>,
    <span class="hljs-attr">author</span>: {
        <span class="hljs-attr">name</span>: <span class="hljs-string">"Michel"</span>
    },
    <span class="hljs-attr">likes</span>: [
        <span class="hljs-string">"John"</span>, <span class="hljs-string">"Sara"</span>
    ]
})
</code></pre>
<p>In memory that looks as follows. The green boxes indicate <em>observable</em> properties. Note that the <em>values</em> themselves are not observable!</p>
<p><img src="../assets/observed-refs.png" alt="MobX reacts to changing references"></p>
<p>Now what MobX basically does is recording which <em>arrows</em> you use in your function. After that, it will re-run whenever one of these <em>arrows</em> changes; when they start to refer to something else.</p>
<h2><a class="anchor" aria-hidden="true" id="examples"></a><a href="#examples" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Examples</h2>
<p>Let's show that with a bunch of examples (based on the <code>message</code> variable defined above):</p>
<h4><a class="anchor" aria-hidden="true" id="correct-dereference-inside-the-tracked-function"></a><a href="#correct-dereference-inside-the-tracked-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Correct: dereference inside the tracked function</h4>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.title)
})
message.title = <span class="hljs-string">"Bar"</span>
</code></pre>
<p>This will react as expected, the <code>.title</code> property was dereferenced by the autorun, and changed afterwards, so this change is detected.</p>
<p>You can verify what MobX will track by calling <a href="../reguide/trace"><code>trace()</code></a> inside the tracked function. In the case of the above function it will output the following:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> disposer = autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.title)
    trace()
})

<span class="hljs-comment">// Outputs:</span>
<span class="hljs-comment">// [mobx.trace] 'Autorun@2' tracing enabled</span>

message.title = <span class="hljs-string">"Hello"</span>
<span class="hljs-comment">// [mobx.trace] 'Autorun@2' is invalidated due to a change in: 'ObservableObject@1.title'</span>
</code></pre>
<p>It is also possible to get the internal dependency (or observer) tree by using the designated utilities for that:</p>
<pre><code class="hljs css language-javascript">getDependencyTree(disposer) <span class="hljs-comment">// prints the dependency tree of the reaction coupled to the disposer</span>
<span class="hljs-comment">// { name: 'Autorun@4',</span>
<span class="hljs-comment">//  dependencies: [ { name: 'ObservableObject@1.title' } ] }</span>
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="incorrect-changing-a-non-observable-reference"></a><a href="#incorrect-changing-a-non-observable-reference" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Incorrect: changing a non-observable reference</h4>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.title)
})
message = observable({ <span class="hljs-attr">title</span>: <span class="hljs-string">"Bar"</span> })
</code></pre>
<p>This will <strong>not</strong> react. <code>message</code> was changed, but <code>message</code> is not an observable, just a variable which <em>refers to</em> an observable,
but the variable (reference) itself is not observable.</p>
<h4><a class="anchor" aria-hidden="true" id="incorrect-dereference-outside-a-tracked-function"></a><a href="#incorrect-dereference-outside-a-tracked-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Incorrect: dereference outside a tracked function</h4>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">var</span> title = message.title;
autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(title)
})
message.title = <span class="hljs-string">"Bar"</span>
</code></pre>
<p>This will <strong>not</strong> react. <code>message.title</code> was dereferenced outside the <code>autorun</code>, and just contains the value of <code>message.title</code> at the  moment of dereferencing (the string <code>&quot;Foo&quot;</code>).
<code>title</code> is not an observable so <code>autorun</code> will never react.</p>
<h4><a class="anchor" aria-hidden="true" id="correct-dereference-inside-the-tracked-function-1"></a><a href="#correct-dereference-inside-the-tracked-function-1" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Correct: dereference inside the tracked function</h4>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.author.name)
})
message.author.name = <span class="hljs-string">"Sara"</span>;
message.author = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };
</code></pre>
<p>This will react to both changes. Both <code>author</code> and <code>author.name</code> are dotted into, allowing MobX to track these references.</p>
<h4><a class="anchor" aria-hidden="true" id="incorrect-store-a-local-reference-to-an-observable-object-without-tracking"></a><a href="#incorrect-store-a-local-reference-to-an-observable-object-without-tracking" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Incorrect: store a local reference to an observable object without tracking</h4>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> author = message.author;
autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(author.name)
})
message.author.name = <span class="hljs-string">"Sara"</span>;
message.author = { <span class="hljs-attr">name</span>: <span class="hljs-string">"John"</span> };
</code></pre>
<p>The first change will be picked up, <code>message.author</code> and <code>author</code> are the same object, and the <code>.name</code> property is dereferenced in the autorun.
However the second change will <strong>not</strong> be picked up, the <code>message.author</code> relation is not tracked by the <code>autorun</code>. Autorun is still using the &quot;old&quot; <code>author</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="common-pitfall-consolelog"></a><a href="#common-pitfall-consolelog" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Common pitfall: console.log</h4>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> message = observable({ <span class="hljs-attr">title</span>: <span class="hljs-string">"hello"</span> })

autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message)
})

<span class="hljs-comment">// Won't trigger a re-run</span>
message.title = <span class="hljs-string">"Hello world"</span>
</code></pre>
<p>In the above example, the updated message title won't be printed, because it is not used inside the autorun.
The autorun only depends on <code>message</code>, which is not an observable, but a constant. In other words, as far as MobX is concerned, <code>title</code> is not used in- and hence not relevant for the <code>autorun</code></p>
<p>The fact that <code>console.log</code> will print the message title is misleading here; <code>console.log</code> is an asynchronous api that only will format its parameters later in time, for which reason the autorun won't be tracking what data the console.log is accessing. For that reason make sure to always pass immutable data or defensive copies to <code>console.log</code>.</p>
<p>The following solutions however, will all react to <code>message.title</code>:</p>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.title) <span class="hljs-comment">// clearly, the `.title` observable is used</span>
})

autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(mobx.toJS(message)) <span class="hljs-comment">// toJS creates a deep clone, and thus will read the message</span>
})

autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log({...message}) <span class="hljs-comment">// creates a shallow clone, also using `.title` in the process</span>
})

autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-built_in">JSON</span>.stringify(message)) <span class="hljs-comment">// also reads the entire structure</span>
})
</code></pre>
<h4><a class="anchor" aria-hidden="true" id="correct-access-array-properties-in-tracked-function"></a><a href="#correct-access-array-properties-in-tracked-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Correct: access array properties in tracked function</h4>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.likes.length);
})
message.likes.push(<span class="hljs-string">"Jennifer"</span>);
</code></pre>
<p>This will react as expected. <code>.length</code> counts towards a property.
Note that this will react to <em>any</em> change in the array.
Arrays are not tracked per index / property (like observable objects and maps) but as a whole.</p>
<h4><a class="anchor" aria-hidden="true" id="incorrect-access-out-of-bounds-indices-in-tracked-function"></a><a href="#incorrect-access-out-of-bounds-indices-in-tracked-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Incorrect: access out-of-bounds indices in tracked function</h4>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.likes[<span class="hljs-number">0</span>]);
})
message.likes.push(<span class="hljs-string">"Jennifer"</span>);
</code></pre>
<p>This will react with the above sample data, array indexers count as property access. But <strong>only</strong> if the provided <code>index &lt; length</code>.
MobX will not track not-yet-existing indices or object properties (except when using maps).
So always guard your array index based access with a <code>.length</code> check.</p>
<h4><a class="anchor" aria-hidden="true" id="correct-access-array-functions-in-tracked-function"></a><a href="#correct-access-array-functions-in-tracked-function" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Correct: access array functions in tracked function</h4>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.likes.join(<span class="hljs-string">", "</span>));
})
message.likes.push(<span class="hljs-string">"Jennifer"</span>);
</code></pre>
<p>This will react as expected. All array functions that do not mutate the array are tracked automatically.</p>
<hr>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.likes.join(<span class="hljs-string">", "</span>));
})
message.likes[<span class="hljs-number">2</span>] = <span class="hljs-string">"Jennifer"</span>;
</code></pre>
<p>This will react as expected. All array index assignments are detected, but only if <code>index &lt;= length</code>.</p>
<h4><a class="anchor" aria-hidden="true" id="incorrect-use-an-observable-but-without-accessing-any-of-its-properties"></a><a href="#incorrect-use-an-observable-but-without-accessing-any-of-its-properties" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Incorrect: &quot;use&quot; an observable but without accessing any of its properties</h4>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    message.likes;
})
message.likes.push(<span class="hljs-string">"Jennifer"</span>);
</code></pre>
<p>This will <strong>not</strong> react. Simply because the <code>likes</code> array itself is not being used by the <code>autorun</code>, only the reference to the array.
So in contrast, <code>messages.likes = [&quot;Jennifer&quot;]</code> would be picked up; that statement does not modify the array, but the <code>likes</code> property itself.</p>
<h4><a class="anchor" aria-hidden="true" id="using-non-observable-object-properties"></a><a href="#using-non-observable-object-properties" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Using non-observable object properties</h4>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.postDate)
})
message.postDate = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
</code></pre>
<p><em>MobX 4</em></p>
<p>This will <strong>not</strong> react. MobX can only track observable properties, and 'postDate' has not been defined as observable property above.
However, it is possible to use the <code>get</code> and <code>set</code> methods as exposed by MobX to work around this:</p>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">get</span>(message, "postDate"))
})
<span class="hljs-keyword">set</span>(message, "postDate",  new Date())
</code></pre>
<p><em>MobX 5</em></p>
<p>In MobX 5 this <strong>will</strong> react, as MobX 5 can track not-yet existing properties.
Note that this is only done for objects created with <code>observable</code> or <code>observable.object</code>.
New properties on class instances will not be made observable automatically.</p>
<h4><a class="anchor" aria-hidden="true" id="mobx-4-and-lower-incorrect-using-not-yet-existing-observable-object-properties"></a><a href="#mobx-4-and-lower-incorrect-using-not-yet-existing-observable-object-properties" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>[MobX 4 and lower] Incorrect: using not yet existing observable object properties</h4>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(message.postDate)
})
extendObservable(message, {
    <span class="hljs-attr">postDate</span>: <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>()
})
</code></pre>
<p>This will <strong>not</strong> react. MobX will not react to observable properties that did not exist when tracking started.
If the two statements are swapped, or if any other observable causes the <code>autorun</code> to re-run, the <code>autorun</code> will start tracking the <code>postDate</code> as well.</p>
<h4><a class="anchor" aria-hidden="true" id="correct-using-not-yet-existing-map-entries"></a><a href="#correct-using-not-yet-existing-map-entries" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Correct: using not yet existing map entries</h4>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> twitterUrls = observable.map({
    <span class="hljs-string">"John"</span>: <span class="hljs-string">"twitter.com/johnny"</span>
})

autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(twitterUrls.get(<span class="hljs-string">"Sara"</span>))
})
twitterUrls.set(<span class="hljs-string">"Sara"</span>, <span class="hljs-string">"twitter.com/horsejs"</span>)
</code></pre>
<p>This <strong>will</strong> react. Observable maps support observing entries that may not exist.
Note that this will initially print <code>undefined</code>.
You can check for the existence of an entry first by using <code>twitterUrls.has(&quot;Sara&quot;)</code>.
So for dynamically keyed collections, always use observable maps.</p>
<h4><a class="anchor" aria-hidden="true" id="correct-using-mobx-utilities-to-read-write-to-objects"></a><a href="#correct-using-mobx-utilities-to-read-write-to-objects" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Correct: using MobX utilities to read / write to objects</h4>
<p>Since MobX 4 it is also possible to use observable objects as dynamic collection, if they are read / updated by using the mobx apis, so that mobx can keep track of the property changes. The following will react as well:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">import</span> { <span class="hljs-keyword">get</span>, <span class="hljs-keyword">set</span>, observable } from "mobx"

const twitterUrls = observable.object({
    <span class="hljs-string">"John"</span>: <span class="hljs-string">"twitter.com/johnny"</span>
})

autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(<span class="hljs-keyword">get</span>(twitterUrls, "Sara")) // <span class="hljs-keyword">get</span> can track not yet existing properties
})
<span class="hljs-keyword">set</span>(twitterUrls, { <span class="hljs-string">"Sara"</span> : <span class="hljs-string">"twitter.com/horsejs"</span>})
</code></pre>
<p>See the <a href="https://mobx.js.org/refguide/api.html#direct-observable-manipulation">object manipulation api</a> for more details</p>
<h2><a class="anchor" aria-hidden="true" id="mobx-only-tracks-synchronously-accessed-data"></a><a href="#mobx-only-tracks-synchronously-accessed-data" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MobX only tracks synchronously accessed data</h2>
<pre><code class="hljs css language-javascript"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">upperCaseAuthorName</span>(<span class="hljs-params">author</span>) </span>{
    <span class="hljs-keyword">const</span> baseName = author.name;
    <span class="hljs-keyword">return</span> baseName.toUpperCase();
}
autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    <span class="hljs-built_in">console</span>.log(upperCaseAuthorName(message.author))
})
message.author.name = <span class="hljs-string">"Chesterton"</span>
</code></pre>
<p>This will react. Even though <code>author.name</code> is not dereferenced by the thunk passed to <code>autorun</code> itself,
MobX will still track the dereferencing that happens in <code>upperCaseAuthorName</code>,
because it happens <em>during</em> the execution of the autorun.</p>
<hr>
<pre><code class="hljs css language-javascript">autorun(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> {
    setTimeout(
        <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-built_in">console</span>.log(message.likes.join(<span class="hljs-string">", "</span>)),
        <span class="hljs-number">10</span>
    )
})
message.likes.push(<span class="hljs-string">"Jennifer"</span>);
</code></pre>
<p>This will <strong>not</strong> react, during the execution of the <code>autorun</code> no observables where accessed, only during the <code>setTimeout</code>.
In general this is quite obvious and rarely causes issues.</p>
<h2><a class="anchor" aria-hidden="true" id="mobx-only-tracks-data-accessed-for-observer-components-if-they-are-directly-accessed-by-render"></a><a href="#mobx-only-tracks-data-accessed-for-observer-components-if-they-are-directly-accessed-by-render" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>MobX only tracks data accessed for <code>observer</code> components if they are directly accessed by <code>render</code></h2>
<p>A common mistake made with <code>observer</code> is that it doesn't track data that syntactically seems parent of the <code>observer</code> component,
but in practice is actually rendered out by a different component. This often happens when render callbacks of components are passed in first class to another component.</p>
<p>Take for example the following contrived example:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> MyComponent = observer(<span class="hljs-function">(<span class="hljs-params">{ message }</span>) =&gt;</span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SomeContainer</span>
        <span class="hljs-attr">title</span> = <span class="hljs-string">{()</span> =&gt;</span> <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{message.title}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
    /&gt;
)

message.title = "Bar"
</span></code></pre>
<p>At first glance everything might seem ok here, except that the <code>&lt;div&gt;</code> is actually not rendered by <code>MyComponent</code> (which has a tracked rendering), but by <code>SomeContainer</code>.
So to make sure that the title of <code>SomeContainer</code> correctly reacts to a new <code>message.title</code>, <code>SomeContainer</code> should be an <code>observer</code> as well.</p>
<p>If <code>SomeContainer</code> comes from an external lib, this is often not under your own control. In that case you can address this by either wrapping the <code>div</code> in its own stateless <code>observer</code> based component, or by leveraging the <code>&lt;Observer&gt;</code> component:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> MyComponent = observer(<span class="hljs-function">(<span class="hljs-params">{ message }</span>) =&gt;</span>
    &lt;SomeContainer
        title = {() =&gt; &lt;TitleRenderer message={message} /&gt;}
    /&gt;
)

const TitleRenderer = observer(({ message }) =&gt;
    &lt;div&gt;{message.title}&lt;/div&gt;}
)

message.title = "Bar"
</code></pre>
<p>Alternatively, to avoid creating additional components, it is also possible to use the mobx-react built-in <code>Observer</code> component, which takes no arguments, and a single render function as children:</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> MyComponent = <span class="hljs-function">(<span class="hljs-params">{ message }</span>) =&gt;</span>
    <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">SomeContainer</span>
        <span class="hljs-attr">title</span> = <span class="hljs-string">{()</span> =&gt;</span>
            <span class="hljs-tag">&lt;<span class="hljs-name">Observer</span>&gt;</span>
                {() =&gt; <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{message.title}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>}
            <span class="hljs-tag">&lt;/<span class="hljs-name">Observer</span>&gt;</span>
        }
    /&gt;

message.title = "Bar"
</span></code></pre>
<h2><a class="anchor" aria-hidden="true" id="avoid-caching-observables-in-local-fields"></a><a href="#avoid-caching-observables-in-local-fields" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>Avoid caching observables in local fields</h2>
<p>A common mistake is to store local variables that dereference observables, and then expect components to react. For example:</p>
<pre><code class="hljs css language-javascript">@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span> </span>{
    author;
    <span class="hljs-keyword">constructor</span>(props) {
        <span class="hljs-keyword">super</span>(props)
        <span class="hljs-keyword">this</span>.author = props.message.author;
    }

    render() {
        <span class="hljs-keyword">return</span> <span class="xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>{this.author.name}<span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span>
    }
}
</code></pre>
<p>This component will react to changes in the <code>author</code>'s name, but it won't react to changing the <code>.author</code> of the <code>message</code> itself! Because that dereferencing happened outside <code>render()</code>,
which is the only tracked function of an <code>observer</code> component.
Note that even marking the <code>author</code> component field as <code>@observable</code> field does not solve this; that field is still assigned only once.
This can simply be solved by doing the dereferencing inside <code>render()</code>, or by introducing a computed property on the component instance:</p>
<pre><code class="hljs css language-javascript">@observer <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyComponent</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">React</span>.<span class="hljs-title">component</span> </span>{
    @computed <span class="hljs-keyword">get</span> author() {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.props.message.author
    }
<span class="hljs-comment">// ...</span>
</code></pre>
<h2><a class="anchor" aria-hidden="true" id="how-multiple-components-will-render"></a><a href="#how-multiple-components-will-render" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>How multiple components will render</h2>
<p>Suppose that the following components are used to render our above <code>message</code> object.</p>
<pre><code class="hljs css language-javascript"><span class="hljs-keyword">const</span> Message = observer(<span class="hljs-function">(<span class="hljs-params">{ message }</span>) =&gt;</span>
    &lt;div&gt;
        {message.title}
        &lt;Author author={ message.author } /&gt;
        &lt;Likes likes={ message.likes } /&gt;
    &lt;/div&gt;
)

const Author = observer(({ author }) =&gt;
    &lt;span&gt;{author.name}&lt;/span&gt;
)

const Likes = observer(({ likes }) =&gt;
    &lt;ul&gt;
        {likes.map(like =&gt;
            &lt;li&gt;{like}&lt;/li&gt;
        )}
    &lt;/ul&gt;
)
</code></pre>
<table>
<thead>
<tr><th>change</th><th>re-rendering component</th></tr>
</thead>
<tbody>
<tr><td><code>message.title = &quot;Bar&quot;</code></td><td><code>Message</code></td></tr>
<tr><td><code>message.author.name = &quot;Susan&quot;</code></td><td><code>Author</code> (<code>.author</code> is dereferenced in <code>Message</code>, but didn't change)*</td></tr>
<tr><td><code>message.author = { name: &quot;Susan&quot;}</code></td><td><code>Message</code>, <code>Author</code></td></tr>
<tr><td><code>message.likes[0] = &quot;Michel&quot;</code></td><td><code>Likes</code></td></tr>
</tbody>
</table>
<p>Notes:</p>
<ol>
<li>* If the <code>Author</code> component was invoked like: <code>&lt;Author author={ message.author.name} /&gt;</code>. Then <code>Message</code> would be the dereferencing component and react to changes to <code>message.author.name</code>. Nonetheless <code>&lt;Author&gt;</code> would rerender as well, because it receives a new value. So performance wise it is best to dereference as late as possible.</li>
<li>** If likes were objects instead of strings, and if they were rendered by their own <code>Like</code> component, the <code>Likes</code> component would not rerender for changes happening inside a specific like.</li>
</ol>
<h2><a class="anchor" aria-hidden="true" id="tl-dr"></a><a href="#tl-dr" aria-hidden="true" class="hash-link"><svg class="hash-link-icon" aria-hidden="true" height="16" version="1.1" viewBox="0 0 16 16" width="16"><path fill-rule="evenodd" d="M4 9h1v1H4c-1.5 0-3-1.69-3-3.5S2.55 3 4 3h4c1.45 0 3 1.69 3 3.5 0 1.41-.91 2.72-2 3.25V8.59c.58-.45 1-1.27 1-2.09C10 5.22 8.98 4 8 4H4c-.98 0-2 1.22-2 2.5S3 9 4 9zm9-3h-1v1h1c1 0 2 1.22 2 2.5S13.98 12 13 12H9c-.98 0-2-1.22-2-2.5 0-.83.42-1.64 1-2.09V6.25c-1.09.53-2 1.84-2 3.25C6 11.31 7.55 13 9 13h4c1.45 0 3-1.69 3-3.5S14.5 6 13 6z"></path></svg></a>TL;DR</h2>
<blockquote>
<p>MobX reacts to any <em>existing</em> <strong>observable</strong> <em>property</em> that is read during the execution of a tracked function.</p>
</blockquote>
</span></div></article></div><div class="docs-prevnext"><a class="docs-prev button" href="refguide/observer-component.html"><span class="arrow-prev">← </span><span>(@)observer</span></a><a class="docs-next button" href="refguide/action.html"><span>action</span><span class="arrow-next"> →</span></a></div></div></div><nav class="onPageNav"><ul class="toc-headings"><li><a href="#mobx-tracks-property-access-not-values">MobX tracks property access, not values</a></li><li><a href="#examples">Examples</a></li><li><a href="#mobx-only-tracks-synchronously-accessed-data">MobX only tracks synchronously accessed data</a></li><li><a href="#mobx-only-tracks-data-accessed-for-observer-components-if-they-are-directly-accessed-by-render">MobX only tracks data accessed for <code>observer</code> components if they are directly accessed by <code>render</code></a></li><li><a href="#avoid-caching-observables-in-local-fields">Avoid caching observables in local fields</a></li><li><a href="#how-multiple-components-will-render">How multiple components will render</a></li><li><a href="#tl-dr">TL;DR</a></li></ul></nav></div><footer class="nav-footer" id="footer"><section class="sitemap"><a href="" class="nav-home"><img src="img/mobx.png" alt="MobX" width="66" height="58"/></a><div><h5>Docs</h5><a href="en/README">Why MobX</a><a href="en/intro/concepts">Concepts</a></div><div><h5>Community</h5><a href="https://stackoverflow.com/questions/tagged/mobx" target="_blank" rel="noreferrer noopener">Stack Overflow</a><a href="https://gitter.im/mobxjs/mobx">Project Chat</a></div><div><h5>More</h5><a class="github-button" href="https://github.com/mobxjs/mobx" data-icon="octicon-star" data-count-href="/facebook/docusaurus/stargazers" data-show-count="true" data-count-aria-label="# stargazers on GitHub" aria-label="Star this project on GitHub">Star</a></div></section></footer></div></body></html>